diff --git a/momentum_algorithm.py b/momentum_algorithm.py
index 7be3561..ae5f0c5 100644
--- a/momentum_algorithm.py
+++ b/momentum_algorithm.py
@@ -12,7 +12,7 @@ from talib.abstract import *
 from gemini_modules import engine
 
 # read in data preserving dates
-df = pd.read_csv("data/USDT_LTC.csv", parse_dates=[0]) 
+df = pd.read_csv("data/USDT_BTC.csv", parse_dates=[0]) 
 
 # df = df.loc['2020-02-13':]
 
@@ -23,14 +23,28 @@ backtest = engine.backtest(df)
 
 # lookback moving average lengths
 # longterm should not be less than RSI lookback length
+
+# define range to sweep
+scales = {
+    'hourly': 2,
+    '4 hourly': 8,
+    '8 hourly': 16,
+    '12 hourly': 24,
+    'daily': 48,
+    '3 daily': 144,
+    'weekly': 336,
+}
+scale =  'daily'
 moving_av_lengths = { 
-    'shortterm' : 27,   
-    'midterm'   : 29,
-    'longterm'  : 33
+    'shortterm' : 9*scales[scale],   
+    'midterm'   : 20*scales[scale],
+    'longterm'  : 30*scales[scale]
 }
 
-RSI_LOW = 28
-RSI_HIGH = 75
+RSI_LOW = 30
+RSI_HIGH = 70
+
+FEE = 0.002
 
 # Flags
 IN_FIRST_DIP = False
@@ -98,24 +112,27 @@ def logic(account, lookback):
             if longterm_is_high and not IN_FIRST_DIP:
                 if (not invested):
                     if (shortterm_moving_average > midterm_moving_average):
-                        # account.buying_power = account.buying_power * 0.999
+                        account.buying_power = account.buying_power * (1-FEE)
                         # account.buying_power = 100
                         account.enter_position('long', account.buying_power, lookback['close'][today])
                         IN_FIRST_DIP = True
 
-                else:   
+                else:
                     for position in account.positions:
                         account.close_position(position, 1, lookback['close'][today])
-                        # account.buying_power = account.buying_power * 0.999
+                        account.buying_power = account.buying_power * (1-FEE)
                         IN_FIRST_DIP = False
+
+            if rsi_score <= RSI_LOW:
+                if invested:
+                    account.buying_power = account.buying_power * (1-FEE)
+                    account.enter_position('long', account.buying_power, lookback['close'][today])
+
             
-            if rsi_score < RSI_LOW and not invested:
-                account.enter_position('long', account.buying_power, lookback['close'][today])
-            
-            # if rsi_score > RSI_HIGH and invested:
-            #     for position in account.positions:
-            #             account.close_position(position, 1, lookback['close'][today])
-            #             # account.buying_power = account.buying_power * 0.999
+            if rsi_score => RSI_HIGH and invested:
+                for position in account.positions:
+                        account.close_position(position, 1, lookback['close'][today])
+                        account.buying_power = account.buying_power * (1-FEE)
                 
             if longterm_is_low:
                 IN_FIRST_DIP = False
@@ -126,59 +143,59 @@ def logic(account, lookback):
 # ------------------------------------[TESTING CODE BELOW]--------------------------------------------------------------------
 
 # mass testing function
-if __name__ == "__main__":
+# if __name__ == "__main__":
 
-    # define range to sweep
-    scale = 1
-    vals = range(10, 101, 10)
-    # vals = [2, 10, 20]
-    vals = list(map(lambda x: x*scale, vals))
+#     # define range to sweep
+#     scale = 48
+#     vals = range(10, 101, 10)
+#     # vals = [2, 10, 20]
+#     vals = list(map(lambda x: x*scale, vals))
 
-    # RSI
-    low_list = [28]
-    high_list = [100]
+#     # RSI
+#     low_list = [28]
+#     high_list = [100]
 
-    # force print to a txt file
-    orig_stdout = sys.stdout
-    count = 0
-    # total = comb(len(vals), 3)
-    total = comb(len(vals),3)*len(low_list)*len(high_list)
+#     # force print to a txt file
+#     orig_stdout = sys.stdout
+#     count = 0
+#     # total = comb(len(vals), 3)
+#     total = comb(len(vals),3)*len(low_list)*len(high_list)
 
-    print(f'\nDoing {total} Backtests ...\n')
-    with open("results-data/temp.txt", "w") as f:
+#     print(f'\nDoing {total} Backtests ...\n')
+#     with open("results-data/temp.txt", "w") as f:
         
-        # test all combinations
-        for short, mid, long in itertools.combinations(vals, 3):
-            for low in low_list:
-                for high in high_list:
-                    t0 = time.time()
-                    sys.stdout = f
+#         # test all combinations
+#         for short, mid, long in itertools.combinations(vals, 3):
+#             for low in low_list:
+#                 for high in high_list:
+#                     t0 = time.time()
+#                     sys.stdout = f
                     
-                    # reset global 
-                    moving_av_lengths = { 
-                        'longterm'  : long, 
-                        'midterm'   : mid,
-                        'shortterm' : short
-                    }
-
-                    RSI_LOW = low
-                    RSI_HIGH = high
+#                     # reset global 
+#                     moving_av_lengths = { 
+#                         'longterm'  : long, 
+#                         'midterm'   : mid,
+#                         'shortterm' : short
+#                     }
+
+#                     RSI_LOW = low
+#                     RSI_HIGH = high
                     
-                    # do testing
-                    print(f'\n({short}, {mid}, {long})')
-                    print(f'\n[{low}, {high}]')
-                    backtest.start(100, logic)
-                    backtest.results()
-                    t1 = time.time()
-                    sys.stdout
-
-                    sys.stdout = orig_stdout
-                    count += 1
-                    print(f'Rolling Averages:\t{short}, {mid}, {long}\nRSI:\t\t\t{low}-{high}\n{int(t1-t0)} secs, ({count}/{total})\n')
-    import parse_results
-    os.system('play -nq -t alsa synth {} sine {}'.format(0.5, 440))
+#                     # do testing
+#                     print(f'\n({short}, {mid}, {long})')
+#                     print(f'\n[{low}, {high}]')
+#                     backtest.start(100, logic)
+#                     backtest.results()
+#                     t1 = time.time()
+#                     sys.stdout
+
+#                     sys.stdout = orig_stdout
+#                     count += 1
+#                     print(f'Rolling Averages:\t{short}, {mid}, {long}\nRSI:\t\t\t{low}-{high}\n{int(t1-t0)} secs, ({count}/{total})\n')
+#     import parse_results
+#     os.system('play -nq -t alsa synth {} sine {}'.format(0.5, 440))
 
-# if __name__ == "__main__":
-#     backtest.start(100, logic)
-#     backtest.results()
-#     backtest.chart()
+if __name__ == "__main__":
+    backtest.start(100, logic)
+    backtest.results()
+    backtest.chart()
